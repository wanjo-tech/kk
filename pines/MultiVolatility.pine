//@version=5
indicator("波动副", shorttitle="波动副")
SP2PVTA(sym,period)=>request.security(sym,period,[close,volume,time/1000, close*volume])

calcMain_imax = 4999
//时间对齐计算 (Time-Aligned Calculation, 以下简称“对时”)
//NOTES：如果是大周期直接用日线数据，15分钟数据适合计算小于49天的周期
calcMain(hr,prz_a,vol_a,time_a,amt_a)=>
    float[] vlta = array.new_float() //for 对数差分
    float[] lnra = array.new_float() //for 累积对数收益
    sumTime = 0, sumVol = 0.0, sumAmt = 0.0, sumAbsPrz = 0.0, sumAbsPrzLog = 0.0, sumPrz = 0.0, sumPrzLog = 0.0
    i = 0, prevPrz = 0.0, przLogDiff = 0.0, przLog = 0.0
    while sumTime < hr * 3600 and i < calcMain_imax
        przLog := math.log(prz_a[i]) //对数价格
        if prevPrz>0.0
            przLogDiff := przLog - math.log(prevPrz) //对数差分用于计算波动率.
            sumAbsPrzLog += math.abs(przLogDiff) //累计对数价格差分长度
            sumAbsPrz += math.abs(prevPrz - prz_a[i]) //累计价格差分长度
            vlta.push(przLogDiff) //用于计算对数价格差分，即波动率的主元素
        lnra.push(przLog) //用于对数收益率的标准差（夏普率sharpe ratio以及无量纲变异系数COV的主元素）
        sumTime := sumTime + nz(time_a[i]-time_a[i+1]) //累计时间，配合i来判断时间计算长度跳出循环.
        sumVol := sumVol + nz(vol_a[i])
        sumAmt := sumAmt + nz(amt_a[i])
        prevPrz := prz_a[i]
        i := i + 1
    if i>0
        sumPrz := prevPrz - prz_a[0] //首尾价格差
        sumPrzLog := math.log(prevPrz) - math.log(prz_a[0]) //首尾对数价格差
    [hr,i,sumPrz,sumAbsPrz,sumPrzLog,sumAbsPrzLog,sumVol,sumAmt,sumTime,array.stdev(vlta),array.stdev(lnra)]

calcMainStd(hr,prz_a,vol_a,time_a,amt_a)=>
    [hrx,i,sumPrz,sumAbsPrz,sumPrzLog,sumAbsPrzLog,sumVol,sumAmt,sumTime,std_vlta,std_lnra]=calcMain(hr,prz_a,vol_a,time_a,amt_a)
    [std_vlta,std_lnra]

symbol0 = syminfo.tickerid
[prz0a_d,vol0a_d,time0a_d,amt0a_d] = SP2PVTA(symbol0,'D')
[prz0a_15m,vol0a_15m,time0a_15m,amt0a_15m] = SP2PVTA(symbol0,'15')

bs365=100*math.sqrt(365)
bs252=100*math.sqrt(252)

//传统波动率：计算过去20天对数差分的标准差, 只对日线图才有少少意义，所以这里只在日线图画出
logdiff_d = math.log(prz0a_d / prz0a_d[1]) //对数差分
volatility20d = ta.stdev(logdiff_d, 20)
plot(timeframe.period=='D'?(bs252*volatility20d):na,color=color.green)


//对时波动率（基于D数据重新统计，用于在细周期图仍能画出“传统波动率”。但因为对时，所以跟传统会有区别）
[vlt20d_,lnr20d_] = calcMainStd(24*20,prz0a_d,vol0a_d,time0a_d,amt0a_d)
plot(bs365*vlt20d_,color=color.red)

//20天对时波动率（基于15分钟数据统计,所以比上面体现得更合理更滑一些）
[vlt20d,lnr20d] = calcMainStd(24*20,prz0a_15m,vol0a_15m,time0a_15m,amt0a_15m)
//plot(timeframe.period=='D'?na:(100*math.sqrt(365)*vlt20d),color=color.blue)
plot(bs365*vlt20d,color=color.blue,linewidth = 2) 

//七天对时波动率
[vlt7d,lnr7d] = calcMainStd(24*7,prz0a_15m,vol0a_15m,time0a_15m,amt0a_15m)
plot(bs365*vlt7d,color=color.black,linewidth = 2) 

//测试对时x天年化收益标准差，跟为跟差分数量级不一样，放在另一个副图；
// plot(bs365*lnr20d/20,color=color.orange)
// plot(bs365*lnr7d/7,color=color.purple)


